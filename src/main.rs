pub mod cli;
pub mod messages;
pub mod transport;

use crate::{
    cli::{Cli, CliDebugCommand, Subcommand},
    transport::{DeviceProtocolAdapter, ProtocolAdapter, UsbTransport},
};
use anyhow::{anyhow, Result};
use clap::Parser;
use rusb::{Device, GlobalContext};
use std::panic;

const DEVICE_IDS: &[(u16, u16)] = &[(0x2b24, 0x0001), (0x2b24, 0x0002)];

fn list_devices() -> Box<[Device<GlobalContext>]> {
    rusb::devices()
        .unwrap()
        .iter()
        .filter(|device| {
            let device_desc = device.device_descriptor().unwrap();
            DEVICE_IDS.contains(&(device_desc.vendor_id(), device_desc.product_id()))
        })
        .collect()
}

fn get_device() -> Result<Device<GlobalContext>> {
    Ok(list_devices()
        .into_iter()
        .nth(0)
        .ok_or_else(|| anyhow!("no device found"))?
        .to_owned())
}

fn main() -> Result<()> {
    // clap needs too much memory to parse things for some reason -- something
    // to do with the code generated by its derive macros I think -- and it's
    // easier to just give it an extra couple of megs than to fix the problem.
    let cli = std::thread::Builder::new()
        .stack_size(4 * 1024 * 1024)
        .spawn(|| Cli::parse())
        .unwrap()
        .join();
    let cli = match cli {
        Ok(x) => x,
        Err(x) => panic::resume_unwind(x),
    };

    if let Subcommand::List(_) = cli.command {
        for device in list_devices().iter() {
            let device_desc = device.device_descriptor()?;
            let device_handle = device.open()?;
            println!(
                "Bus {:03} Device {:03} ID {:04x}:{:04x}\t\"{}\"\t({})",
                device.bus_number(),
                device.address(),
                device_desc.vendor_id(),
                device_desc.product_id(),
                device_handle.read_product_string_ascii(&device_desc)?,
                device_handle.read_serial_number_string_ascii(&device_desc)?,
            );
        }
        return Ok(());
    }

    let protocol_adapter = UsbTransport::new(get_device()?, 1).map(|x| {
        let mut out = DeviceProtocolAdapter::new(x);
        out.verbose = cli.verbose;
        out
    })?;

    let debug_protocol_adapter = UsbTransport::new(get_device()?, 2)
        .map(|x| {
            let mut out = DeviceProtocolAdapter::new(x);
            out.verbose = cli.verbose;
            out
        })
        .ok();

    cli.handle_debug(
        &protocol_adapter,
        debug_protocol_adapter
            .as_ref()
            .map(|x| -> &dyn ProtocolAdapter { x }),
    )
}
