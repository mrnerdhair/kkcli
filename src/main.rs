pub mod cli;
pub mod messages;
pub mod transport;

use crate::{
    cli::{Cli, CliDebugCommand, Subcommand},
    transport::{ProtocolAdapter, UsbTransport},
};
use anyhow::{anyhow, Result};
use clap::Parser;
use rusb::{Device, GlobalContext};
use std::panic;

const DEVICE_IDS: &[(u16, u16)] = &[(0x2b24, 0x0001), (0x2b24, 0x0002)];

fn list_devices() -> Box<[Device<GlobalContext>]> {
    rusb::devices()
        .unwrap()
        .iter()
        .filter(|device| {
            let device_desc = device.device_descriptor().unwrap();
            DEVICE_IDS.contains(&(device_desc.vendor_id(), device_desc.product_id()))
        })
        .collect()
}

fn get_device() -> Result<Device<GlobalContext>> {
    Ok(list_devices()
        .iter()
        .next()
        .ok_or_else(|| anyhow!("no device found"))?
        .to_owned())
}

fn main() -> Result<()> {
    // clap needs too much memory to parse things for some reason -- something
    // to do with the code generated by its derive macros I think -- and it's
    // easier to just give it an extra couple of megs than to fix the problem.
    let cli = std::thread::Builder::new()
        .stack_size(4 * 1024 * 1024)
        .spawn(Cli::parse)
        .unwrap()
        .join();
    let cli = match cli {
        Ok(x) => x,
        Err(x) => panic::resume_unwind(x),
    };

    match cli.command {
        Subcommand::List(_) => {
            for device in list_devices().iter() {
                let device_desc = device.device_descriptor()?;
                let device_handle = device.open()?;
                println!(
                    "Bus {:03} Device {:03} ID {:04x}:{:04x}\t\"{}\"\t({})",
                    device.bus_number(),
                    device.address(),
                    device_desc.vendor_id(),
                    device_desc.product_id(),
                    device_handle.read_product_string_ascii(&device_desc)?,
                    device_handle.read_serial_number_string_ascii(&device_desc)?,
                );
            }
            return Ok(());
        }
        Subcommand::Decode(x) => {
            x.handle()?;
            return Ok(());
        }
        _ => (),
    }
    *transport::protocol_adapter::VERBOSE.write().unwrap() = cli.verbose;

    let device = get_device()?;
    let (mut transport, config_descriptor, handle) = UsbTransport::new(&device, 0)?;
    let mut debug_transport =
        UsbTransport::new_from_descriptor_and_handle(&config_descriptor, handle, 1).ok();

    cli.handle_debug(
        &mut transport,
        debug_transport
            .as_mut()
            .map(|x| -> &mut dyn ProtocolAdapter { x }),
    )
}
