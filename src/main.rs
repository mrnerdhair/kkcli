#![recursion_limit = "256"]

pub mod cli;
pub mod messages;
pub mod state_machine;
pub mod transport;

use crate::{
    cli::{Cli, Command, CliCommand},
    transport::UsbTransport,
};
use anyhow::{anyhow, Result};
use clap::Parser;
use rusb::{Device, GlobalContext};
use state_machine::TransportStateMachine;
use std::panic;

const DEVICE_IDS: &[(u16, u16)] = &[(0x2b24, 0x0001), (0x2b24, 0x0002)];

fn list_devices() -> Box<[Device<GlobalContext>]> {
    rusb::devices()
        .unwrap()
        .iter()
        .filter(|device| {
            let device_desc = device.device_descriptor().unwrap();
            DEVICE_IDS.contains(&(device_desc.vendor_id(), device_desc.product_id()))
        })
        .collect()
}

fn get_device() -> Result<Device<GlobalContext>> {
    Ok(list_devices()
        .into_iter()
        .nth(0)
        .ok_or_else(|| anyhow!("no device found"))?
        .to_owned())
}

fn main() -> Result<()> {
    // clap needs too much memory to parse things for some reason -- something
    // to do with the code generated by its derive macros I think -- and it's
    // easier to just give it an extra couple of megs than to fix the problem.
    let cli = std::thread::Builder::new()
        .stack_size(4 * 1024 * 1024)
        .spawn(|| Cli::parse())
        .unwrap()
        .join();
    let cli = match cli {
        Ok(x) => x,
        Err(x) => panic::resume_unwind(x),
    };

    if let Command::List(_) = cli.command {
        for device in list_devices().iter() {
            let device_desc = device.device_descriptor()?;
            let device_handle = device.open()?;
            println!(
                "Bus {:03} Device {:03} ID {:04x}:{:04x}\t\"{}\"\t({})",
                device.bus_number(),
                device.address(),
                device_desc.vendor_id(),
                device_desc.product_id(),
                device_handle.read_product_string_ascii(&device_desc)?,
                device_handle.read_serial_number_string_ascii(&device_desc)?,
            );
        }
        return Ok(());
    }

    let transport = UsbTransport::new(get_device()?)?;
    let mut state_machine = TransportStateMachine::new(&transport);
    state_machine.verbose = cli.verbose;
    let state_machine = state_machine;

    cli.handle(&state_machine)
}
